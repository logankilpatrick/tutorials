var documenterSearchIndex = {"docs":
[{"location":"generated/quick-start/5.shor-9-code/#","page":"Shor's 9 qubit code","title":"Shor's 9 qubit code","text":"EditURL = \"https://github.com/QuantumBFS/tutorials/blob/master/quick-start/5.shor-9-code/main.jl\"","category":"page"},{"location":"generated/quick-start/5.shor-9-code/#","page":"Shor's 9 qubit code","title":"Shor's 9 qubit code","text":"(Image: ) (Image: )","category":"page"},{"location":"generated/quick-start/5.shor-9-code/#Shor's-9-qubit-code-1","page":"Shor's 9 qubit code","title":"Shor's 9 qubit code","text":"","category":"section"},{"location":"generated/quick-start/5.shor-9-code/#","page":"Shor's 9 qubit code","title":"Shor's 9 qubit code","text":"The well-known Shor's 9 qubit code can correct any single Pauli error, but it can also correct some other kinds of errors. Its circuit is shown as below (Image: shor-9-circuit) which can be constructed by the following code","category":"page"},{"location":"generated/quick-start/5.shor-9-code/#","page":"Shor's 9 qubit code","title":"Shor's 9 qubit code","text":"using Yao\n\nshor(E) = chain(9,\n    # encode circuit\n    cnot(1, 4), cnot(1, 7),\n    put(1=>H), put(4=>H), put(7=>H),\n    cnot(1,2), cnot(1,3), cnot(4,5), cnot(4,6), cnot(7,8), cnot(7,9),\n    E, # the error\n    # decode circuit\n    cnot(1,2), cnot(1,3), cnot((2, 3), 1),\n    cnot(4,5), cnot(4,6), cnot((5, 6), 4),\n    cnot(7,8), cnot(7,9), cnot((8, 9), 7),\n    put(1=>H), put(4=>H), put(7=>H), cnot(1, 4), cnot(1, 7), cnot((4, 7), 1)\n)","category":"page"},{"location":"generated/quick-start/5.shor-9-code/#","page":"Shor's 9 qubit code","title":"Shor's 9 qubit code","text":"Now we can check whether it can correct a given error by doing symbolic computation on a 1-qubit quantum state α0 + β1 and an arbitrary weight-9 error.","category":"page"},{"location":"generated/quick-start/5.shor-9-code/#","page":"Shor's 9 qubit code","title":"Shor's 9 qubit code","text":"@vars α β\ns = α * ket\"0\" + β * ket\"1\" |> addbits!(8)\nE = kron(1=>X, 2=>Z, 3=>Z, 4=>X, 5=>Z, 6=>Z, 7=>X, 8=>Z, 9=>Z);\ns |> shor(E) |> partial_tr(2:9) |> expand","category":"page"},{"location":"generated/quick-start/5.shor-9-code/#","page":"Shor's 9 qubit code","title":"Shor's 9 qubit code","text":"","category":"page"},{"location":"generated/quick-start/5.shor-9-code/#","page":"Shor's 9 qubit code","title":"Shor's 9 qubit code","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/quick-start/1.prepare-ghz-state/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"EditURL = \"https://github.com/QuantumBFS/tutorials/blob/master/quick-start/1.prepare-ghz-state/main.jl\"","category":"page"},{"location":"generated/quick-start/1.prepare-ghz-state/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"(Image: ) (Image: )","category":"page"},{"location":"generated/quick-start/1.prepare-ghz-state/#example-ghz-1","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"","category":"section"},{"location":"generated/quick-start/1.prepare-ghz-state/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"First, you have to use this package in Julia.","category":"page"},{"location":"generated/quick-start/1.prepare-ghz-state/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"using Yao","category":"page"},{"location":"generated/quick-start/1.prepare-ghz-state/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"Now, we just define the circuit according to the circuit image below: (Image: ghz)","category":"page"},{"location":"generated/quick-start/1.prepare-ghz-state/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"circuit = chain(\n    4,\n    put(1=>X),\n    repeat(H, 2:4),\n    control(2, 1=>X),\n    control(4, 3=>X),\n    control(3, 1=>X),\n    control(4, 3=>X),\n    repeat(H, 1:4),\n)","category":"page"},{"location":"generated/quick-start/1.prepare-ghz-state/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"Let me explain what happens here.","category":"page"},{"location":"generated/quick-start/1.prepare-ghz-state/#Put-single-qubit-gate-X-to-location-1-1","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Put single qubit gate X to location 1","text":"","category":"section"},{"location":"generated/quick-start/1.prepare-ghz-state/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"we have an X gate applied to the first qubit. We need to tell Yao to put this gate on the first qubit by","category":"page"},{"location":"generated/quick-start/1.prepare-ghz-state/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"put(4, 1=>X)","category":"page"},{"location":"generated/quick-start/1.prepare-ghz-state/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"We use Julia's Pair to denote the gate and its location in the circuit, for two-qubit gate, you could also use a tuple of locations:","category":"page"},{"location":"generated/quick-start/1.prepare-ghz-state/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"put(4, (1, 2)=>swap(2, 1, 2))","category":"page"},{"location":"generated/quick-start/1.prepare-ghz-state/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"But, wait, why there's no 4 in the definition above? This is because all the functions in Yao that requires to input the number of qubits as its first arguement could be lazy (curried), and let other constructors to infer the total number of qubits later, e.g","category":"page"},{"location":"generated/quick-start/1.prepare-ghz-state/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"put(1=>X)","category":"page"},{"location":"generated/quick-start/1.prepare-ghz-state/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"which will return a lambda that ask for a single arguement n.","category":"page"},{"location":"generated/quick-start/1.prepare-ghz-state/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"put(1=>X)(4)","category":"page"},{"location":"generated/quick-start/1.prepare-ghz-state/#Apply-the-same-gate-on-different-locations-1","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Apply the same gate on different locations","text":"","category":"section"},{"location":"generated/quick-start/1.prepare-ghz-state/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"next we should put Hadmard gates on all locations except the 1st qubits.","category":"page"},{"location":"generated/quick-start/1.prepare-ghz-state/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"We provide repeat to apply the same block repeatly, repeat can take an iterator of desired locations, and like put, we can also leave the total number of qubits there.","category":"page"},{"location":"generated/quick-start/1.prepare-ghz-state/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"repeat(H, 2:4)","category":"page"},{"location":"generated/quick-start/1.prepare-ghz-state/#Define-control-gates-1","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Define control gates","text":"","category":"section"},{"location":"generated/quick-start/1.prepare-ghz-state/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"In Yao, we could define controlled gates by feeding a gate to control","category":"page"},{"location":"generated/quick-start/1.prepare-ghz-state/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"control(4, 2, 1=>X)","category":"page"},{"location":"generated/quick-start/1.prepare-ghz-state/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"Like many others, you could leave the number of total qubits there, and infer it later.","category":"page"},{"location":"generated/quick-start/1.prepare-ghz-state/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"control(2, 1=>X)","category":"page"},{"location":"generated/quick-start/1.prepare-ghz-state/#Composite-each-part-together-1","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Composite each part together","text":"","category":"section"},{"location":"generated/quick-start/1.prepare-ghz-state/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"This will create a ControlBlock, the concept of block in Yao basically just means quantum operators, since the quantum circuit itself is a quantum operator, we could create a quantum circuit by composite each part of.","category":"page"},{"location":"generated/quick-start/1.prepare-ghz-state/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"Here, we use chain to chain each part together, a chain of quantum operators means to apply each operators one by one in the chain. This will create a ChainBlock.","category":"page"},{"location":"generated/quick-start/1.prepare-ghz-state/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"circuit = chain(\n    4,\n    put(1=>X),\n    repeat(H, 2:4),\n    control(2, 1=>X),\n    control(4, 3=>X),\n    control(3, 1=>X),\n    control(4, 3=>X),\n    repeat(H, 1:4),\n)","category":"page"},{"location":"generated/quick-start/1.prepare-ghz-state/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"You can check the type of it with typeof","category":"page"},{"location":"generated/quick-start/1.prepare-ghz-state/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"typeof(circuit)","category":"page"},{"location":"generated/quick-start/1.prepare-ghz-state/#Construct-GHZ-state-from-00...00-1","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Construct GHZ state from 00...00","text":"","category":"section"},{"location":"generated/quick-start/1.prepare-ghz-state/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"For simulation, we provide a builtin register type called ArrayReg, we will use the simulated register in this example.","category":"page"},{"location":"generated/quick-start/1.prepare-ghz-state/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"First, let's create 0000, you can create it with zero_state","category":"page"},{"location":"generated/quick-start/1.prepare-ghz-state/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"zero_state(4)","category":"page"},{"location":"generated/quick-start/1.prepare-ghz-state/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"Or we also provide bit string literals to create arbitrary eigen state","category":"page"},{"location":"generated/quick-start/1.prepare-ghz-state/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"ArrayReg(bit\"0000\")","category":"page"},{"location":"generated/quick-start/1.prepare-ghz-state/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"They will both create a register with Julia's builtin Array as storage.","category":"page"},{"location":"generated/quick-start/1.prepare-ghz-state/#Feed-Registers-to-Circuits-1","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Feed Registers to Circuits","text":"","category":"section"},{"location":"generated/quick-start/1.prepare-ghz-state/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"Circuits can be applied to registers with apply!","category":"page"},{"location":"generated/quick-start/1.prepare-ghz-state/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"apply!(zero_state(4), circuit)","category":"page"},{"location":"generated/quick-start/1.prepare-ghz-state/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"or you can use pipe operator |>, when you want to chain several operations together, here we measure the state right after the circuit for 1000 times","category":"page"},{"location":"generated/quick-start/1.prepare-ghz-state/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"results = zero_state(4) |> circuit |> r->measure(r, nshots=1000)\n\nusing StatsBase, Plots\n\nhist = fit(Histogram, Int.(results), 0:16)\nbar(hist.edges[1] .- 0.5, hist.weights, legend=:none)","category":"page"},{"location":"generated/quick-start/1.prepare-ghz-state/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"GHZ state will collapse to 0000 or 1111.","category":"page"},{"location":"generated/quick-start/1.prepare-ghz-state/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"","category":"page"},{"location":"generated/quick-start/1.prepare-ghz-state/#","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/developer-guide/2.cuda-acceleration/#","page":"CUDA acceleration of Quantum Simulation","title":"CUDA acceleration of Quantum Simulation","text":"EditURL = \"https://github.com/QuantumBFS/tutorials/blob/master/developer-guide/2.cuda-acceleration/main.jl\"","category":"page"},{"location":"generated/developer-guide/2.cuda-acceleration/#","page":"CUDA acceleration of Quantum Simulation","title":"CUDA acceleration of Quantum Simulation","text":"(Image: ) (Image: )","category":"page"},{"location":"generated/developer-guide/2.cuda-acceleration/#CUDA-acceleration-of-Quantum-Simulation-1","page":"CUDA acceleration of Quantum Simulation","title":"CUDA acceleration of Quantum Simulation","text":"","category":"section"},{"location":"generated/developer-guide/2.cuda-acceleration/#","page":"CUDA acceleration of Quantum Simulation","title":"CUDA acceleration of Quantum Simulation","text":"For example, a SWAP gate can be instructed on a GPU register like","category":"page"},{"location":"generated/developer-guide/2.cuda-acceleration/#","page":"CUDA acceleration of Quantum Simulation","title":"CUDA acceleration of Quantum Simulation","text":"function instruct!(reg::GPUReg, ::Val{:SWAP}, locs::Tuple{Int,Int})\n    b1, b2 = locs\n    state = statevec(reg)\n    mask1 = bmask(b1)\n    mask2 = bmask(b2)\n\n    function kf(state, mask1, mask2)\n        inds = ((blockIdx().x-1) * blockDim().x + threadIdx().x,\n                       (blockIdx().y-1) * blockDim().y + threadIdx().y)\n        b = inds[1]-1\n        c = inds[2]\n        c <= size(state, 2) || return nothing\n        if b&mask1==0 && b&mask2==mask2\n            i = b+1\n            i_ = b  (mask1|mask2) + 1\n            temp = state[i, c]\n            state[i, c] = state[i_, c]\n            state[i_, c] = temp\n        end\n        nothing\n    end\n    X, Y = cudiv(size(state)...)\n    @cuda threads=X blocks=Y kf(state, mask1, mask2)\n    state\nend","category":"page"},{"location":"generated/developer-guide/2.cuda-acceleration/#","page":"CUDA acceleration of Quantum Simulation","title":"CUDA acceleration of Quantum Simulation","text":"Here, we devide the threads and blocks into a two dimensional grid with a same shape as the input GPUReg storage (i.e. 2^atimes 2^rB). Only if two qubits at locs are 0 and 1 respectively, they are exchanged, otherwise do nothing. Although 34 of threads are idle and plenty room for optimization, from this example, we see how easy CUDA programming is with CUDAnative. In appendix \\App{app-reg}, we show another example of creating a register that echos received instructions.","category":"page"},{"location":"generated/developer-guide/2.cuda-acceleration/#","page":"CUDA acceleration of Quantum Simulation","title":"CUDA acceleration of Quantum Simulation","text":"","category":"page"},{"location":"generated/developer-guide/2.cuda-acceleration/#","page":"CUDA acceleration of Quantum Simulation","title":"CUDA acceleration of Quantum Simulation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/quick-start/6.quantum-circuit-born-machine/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"EditURL = \"https://github.com/QuantumBFS/tutorials/blob/master/quick-start/6.quantum-circuit-born-machine/main.jl\"","category":"page"},{"location":"generated/quick-start/6.quantum-circuit-born-machine/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"(Image: ) (Image: )","category":"page"},{"location":"generated/quick-start/6.quantum-circuit-born-machine/#qcbm-1","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"","category":"section"},{"location":"generated/quick-start/6.quantum-circuit-born-machine/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"Yao is designed with variational quantum circuits in mind, and this tutorial will introduce how to use Yao for this kind of task by implementing a quantum circuit born machine described in Jin-Guo Liu, Lei Wang (2018)","category":"page"},{"location":"generated/quick-start/6.quantum-circuit-born-machine/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"let's use the packages first","category":"page"},{"location":"generated/quick-start/6.quantum-circuit-born-machine/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"using Yao, LinearAlgebra, Plots","category":"page"},{"location":"generated/quick-start/6.quantum-circuit-born-machine/#Training-Target-1","page":"Quantum Circuit Born Machine","title":"Training Target","text":"","category":"section"},{"location":"generated/quick-start/6.quantum-circuit-born-machine/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"In this tutorial, we will ask the variational circuit to learn the most basic distribution: a guassian distribution. It is defined as follows:","category":"page"},{"location":"generated/quick-start/6.quantum-circuit-born-machine/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"f(x left mu sigma^2right) = frac1sqrt2pisigma^2 e^-frac(x-mu)^22sigma^2","category":"page"},{"location":"generated/quick-start/6.quantum-circuit-born-machine/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"We implement it as gaussian_pdf:","category":"page"},{"location":"generated/quick-start/6.quantum-circuit-born-machine/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"function gaussian_pdf(x, μ::Real, σ::Real)\n    pl = @. 1 / sqrt(2pi * σ^2) * exp(-(x - μ)^2 / (2 * σ^2))\n    pl / sum(pl)\nend\npg = gaussian_pdf(1:1<<6, 1<<5-0.5, 1<<4);\nnothing #hide","category":"page"},{"location":"generated/quick-start/6.quantum-circuit-born-machine/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"We can plot the distribution, it looks like","category":"page"},{"location":"generated/quick-start/6.quantum-circuit-born-machine/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"plot(pg)","category":"page"},{"location":"generated/quick-start/6.quantum-circuit-born-machine/#Create-the-Circuit-1","page":"Quantum Circuit Born Machine","title":"Create the Circuit","text":"","category":"section"},{"location":"generated/quick-start/6.quantum-circuit-born-machine/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"A quantum circuit born machine looks like the following:","category":"page"},{"location":"generated/quick-start/6.quantum-circuit-born-machine/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"(Image: differentiable ciruit)","category":"page"},{"location":"generated/quick-start/6.quantum-circuit-born-machine/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"It is composited by two different layers: rotation layer and entangler layer.","category":"page"},{"location":"generated/quick-start/6.quantum-circuit-born-machine/#Rotation-Layer-1","page":"Quantum Circuit Born Machine","title":"Rotation Layer","text":"","category":"section"},{"location":"generated/quick-start/6.quantum-circuit-born-machine/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"Arbitrary rotation is built with Rotation Gate on Z, X, Z axis with parameters.","category":"page"},{"location":"generated/quick-start/6.quantum-circuit-born-machine/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"Rz(theta) cdot Rx(theta) cdot Rz(theta)","category":"page"},{"location":"generated/quick-start/6.quantum-circuit-born-machine/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"Since our input will be a 0dots 0rangle state. The first layer of arbitrary rotation can just use Rx(theta) cdot Rz(theta) and the last layer of arbitrary rotation could just use Rz(theta)cdot Rx(theta)","category":"page"},{"location":"generated/quick-start/6.quantum-circuit-born-machine/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"In 幺, every Hilbert operator is a block type, this ncludes all quantum gates and quantum oracles. In general, operators appears in a quantum circuit can be divided into Composite Blocks and Primitive Blocks.","category":"page"},{"location":"generated/quick-start/6.quantum-circuit-born-machine/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"We follow the low abstraction principle and thus each block represents a certain approach of calculation. The simplest Composite Block is a Chain Block, which chains other blocks (oracles) with the same number of qubits together. It is just a simple mathematical composition of operators with same size. e.g.","category":"page"},{"location":"generated/quick-start/6.quantum-circuit-born-machine/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"textchain(X Y Z) iff X cdot Y cdot Z","category":"page"},{"location":"generated/quick-start/6.quantum-circuit-born-machine/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"We can construct an arbitrary rotation block by chain Rz, Rx, Rz together.","category":"page"},{"location":"generated/quick-start/6.quantum-circuit-born-machine/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"chain(Rz(0.0), Rx(0.0), Rz(0.0))","category":"page"},{"location":"generated/quick-start/6.quantum-circuit-born-machine/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"Rx, Rz will construct new rotation gate, which are just shorthands for rot(X, 0.0), etc.","category":"page"},{"location":"generated/quick-start/6.quantum-circuit-born-machine/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"Then let's chain them up","category":"page"},{"location":"generated/quick-start/6.quantum-circuit-born-machine/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"layer(nbit::Int, x::Symbol) = layer(nbit, Val(x))\nlayer(nbit::Int, ::Val{:first}) = chain(nbit, put(i=>chain(Rx(0), Rz(0))) for i = 1:nbit);\nnothing #hide","category":"page"},{"location":"generated/quick-start/6.quantum-circuit-born-machine/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"We do not need to feed the first n parameter into put here. All factory methods can be lazy evaluate the first arguements, which is the number of qubits. It will return a lambda function that requires a single interger input. The instance of desired block will only be constructed until all the information is filled. When you filled all the information in somewhere of the declaration, 幺 will be able to infer the others. We will now define the rest of rotation layers","category":"page"},{"location":"generated/quick-start/6.quantum-circuit-born-machine/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"layer(nbit::Int, ::Val{:last}) = chain(nbit, put(i=>chain(Rz(0), Rx(0))) for i = 1:nbit)\nlayer(nbit::Int, ::Val{:mid}) = chain(nbit, put(i=>chain(Rz(0), Rx(0), Rz(0))) for i = 1:nbit);\nnothing #hide","category":"page"},{"location":"generated/quick-start/6.quantum-circuit-born-machine/#Entangler-1","page":"Quantum Circuit Born Machine","title":"Entangler","text":"","category":"section"},{"location":"generated/quick-start/6.quantum-circuit-born-machine/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"Another component of quantum circuit born machine are several CNOT operators applied on different qubits.","category":"page"},{"location":"generated/quick-start/6.quantum-circuit-born-machine/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"entangler(pairs) = chain(control(ctrl, target=>X) for (ctrl, target) in pairs);\nnothing #hide","category":"page"},{"location":"generated/quick-start/6.quantum-circuit-born-machine/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"We can then define such a born machine","category":"page"},{"location":"generated/quick-start/6.quantum-circuit-born-machine/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"function build_circuit(n, nlayers, pairs)\n    circuit = chain(n)\n    push!(circuit, layer(n, :first))\n    for i in 2:nlayers\n        push!(circuit, cache(entangler(pairs)))\n        push!(circuit, layer(n, :mid))\n    end\n    push!(circuit, cache(entangler(pairs)))\n    push!(circuit, layer(n, :last))\n    return circuit\nend","category":"page"},{"location":"generated/quick-start/6.quantum-circuit-born-machine/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"We use the method cache here to tag the entangler block that it should be cached after its first run, because it is actually a constant oracle. Let's see what will be constructed","category":"page"},{"location":"generated/quick-start/6.quantum-circuit-born-machine/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"build_circuit(4, 1, [1=>2, 2=>3, 3=>4])","category":"page"},{"location":"generated/quick-start/6.quantum-circuit-born-machine/#MMD-Loss-and-Gradients-1","page":"Quantum Circuit Born Machine","title":"MMD Loss & Gradients","text":"","category":"section"},{"location":"generated/quick-start/6.quantum-circuit-born-machine/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"The MMD loss is describe below:","category":"page"},{"location":"generated/quick-start/6.quantum-circuit-born-machine/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"beginaligned\nmathcalL = left sum_x p theta(x) phi(x) - sum_x pi(x) phi(x) right^2\n            = langle K(x y) rangle_x sim p_theta ysim p_theta - 2 langle K(x y) rangle_xsim p_theta ysim pi + langle K(x y) rangle_xsimpi ysimpi\nendaligned","category":"page"},{"location":"generated/quick-start/6.quantum-circuit-born-machine/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"We will use a squared exponential kernel here.","category":"page"},{"location":"generated/quick-start/6.quantum-circuit-born-machine/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"struct RBFKernel\n    σ::Float64\n    m::Matrix{Float64}\nend\n\nfunction RBFKernel(σ::Float64, space)\n    dx2 = (space .- space').^2\n    return RBFKernel(σ, exp.(-1/2σ * dx2))\nend\n\nkexpect(κ::RBFKernel, x, y) = x' * κ.m * y","category":"page"},{"location":"generated/quick-start/6.quantum-circuit-born-machine/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"There are two different way to define the loss:","category":"page"},{"location":"generated/quick-start/6.quantum-circuit-born-machine/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"In simulation we can use the probability distribution of the state directly","category":"page"},{"location":"generated/quick-start/6.quantum-circuit-born-machine/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"get_prob(qcbm) = probs(zero_state(nqubits(qcbm)) |> qcbm)\n\nfunction loss(κ, c, target)\n    p = get_prob(c) - target\n    return kexpect(κ, p, p)\nend","category":"page"},{"location":"generated/quick-start/6.quantum-circuit-born-machine/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"Or if you want to simulate the whole process with measurement (which is entirely physical), you should define the loss with measurement results, for convenience we directly use the simulated results as our loss","category":"page"},{"location":"generated/quick-start/6.quantum-circuit-born-machine/#Gradients-1","page":"Quantum Circuit Born Machine","title":"Gradients","text":"","category":"section"},{"location":"generated/quick-start/6.quantum-circuit-born-machine/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"the gradient of MMD loss is","category":"page"},{"location":"generated/quick-start/6.quantum-circuit-born-machine/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"beginaligned\nfracpartial mathcalLpartial theta^i_l = langle K(x y) rangle_xsim p_theta^+ ysim p_theta - langle K(x y) rangle_xsim p_theta^- ysim p_theta\n- langle K(x y) rangle _xsim p_theta^+ ysimpi + langle K(x y) rangle_xsim p_theta^- ysimpi\nendaligned","category":"page"},{"location":"generated/quick-start/6.quantum-circuit-born-machine/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"which can be implemented as","category":"page"},{"location":"generated/quick-start/6.quantum-circuit-born-machine/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"function gradient(qcbm, κ, ptrain)\n    n = nqubits(qcbm)\n    prob = get_prob(qcbm)\n    grad = zeros(Float64, nparameters(qcbm))\n\n    count = 1\n    for k in 1:2:length(qcbm), each_line in qcbm[k], gate in content(each_line)\n        dispatch!(+, gate, π/2)\n        prob_pos = probs(zero_state(n) |> qcbm)\n\n        dispatch!(-, gate, π)\n        prob_neg = probs(zero_state(n) |> qcbm)\n\n        dispatch!(+, gate, π/2) # set back\n\n        grad_pos = kexpect(κ, prob, prob_pos) - kexpect(κ, prob, prob_neg)\n        grad_neg = kexpect(κ, ptrain, prob_pos) - kexpect(κ, ptrain, prob_neg)\n        grad[count] = grad_pos - grad_neg\n        count += 1\n    end\n    return grad\nend","category":"page"},{"location":"generated/quick-start/6.quantum-circuit-born-machine/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"Now let's setup the training","category":"page"},{"location":"generated/quick-start/6.quantum-circuit-born-machine/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"using Flux.Optimise\nqcbm = build_circuit(6, 10, [1=>2, 3=>4, 5=>6, 2=>3, 4=>5, 6=>1])\ndispatch!(qcbm, :random) # initialize the parameters\n\nκ = RBFKernel(0.25, 0:2^6-1)\npg = gaussian_pdf(1:1<<6, 1<<5-0.5, 1<<4);\nopt = ADAM()\n\nfunction train(qcbm, κ, opt, target)\n    history = Float64[]\n    for _ in 1:100\n        push!(history, loss(κ, qcbm, target))\n        ps = parameters(qcbm)\n        Optimise.update!(opt, ps, gradient(qcbm, κ, target))\n        popdispatch!(qcbm, ps)\n    end\n    return history\nend\n\nhistory = train(qcbm, κ, opt, pg)\ntrained_pg = probs(zero_state(nqubits(qcbm)) |> qcbm)","category":"page"},{"location":"generated/quick-start/6.quantum-circuit-born-machine/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"The history of training looks like below","category":"page"},{"location":"generated/quick-start/6.quantum-circuit-born-machine/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"title!(\"training history\")\nxlabel!(\"steps\"); ylabel!(\"loss\")\nplot(history)","category":"page"},{"location":"generated/quick-start/6.quantum-circuit-born-machine/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"And let's check what we got","category":"page"},{"location":"generated/quick-start/6.quantum-circuit-born-machine/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"fig2 = plot(1:1<<6, trained_pg; label=\"trained\")\nplot!(fig2, 1:1<<6, pg; label=\"target\")\ntitle!(\"distribution\")\nxlabel!(\"x\"); ylabel!(\"p\")","category":"page"},{"location":"generated/quick-start/6.quantum-circuit-born-machine/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"So within 50 steps, we got a pretty close estimation of our target distribution!","category":"page"},{"location":"generated/quick-start/6.quantum-circuit-born-machine/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"","category":"page"},{"location":"generated/quick-start/6.quantum-circuit-born-machine/#","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/quick-start/7.variation-quantum-eigen-solver/#","page":"Variational Quantum Eigen Solver","title":"Variational Quantum Eigen Solver","text":"EditURL = \"https://github.com/QuantumBFS/tutorials/blob/master/quick-start/7.variation-quantum-eigen-solver/main.jl\"","category":"page"},{"location":"generated/quick-start/7.variation-quantum-eigen-solver/#","page":"Variational Quantum Eigen Solver","title":"Variational Quantum Eigen Solver","text":"(Image: ) (Image: )","category":"page"},{"location":"generated/quick-start/7.variation-quantum-eigen-solver/#Variational-Quantum-Eigen-Solver-1","page":"Variational Quantum Eigen Solver","title":"Variational Quantum Eigen Solver","text":"","category":"section"},{"location":"generated/quick-start/7.variation-quantum-eigen-solver/#","page":"Variational Quantum Eigen Solver","title":"Variational Quantum Eigen Solver","text":"using Yao, Yao.AD, YaoExtensions\n\n\nusing YaoExtensions: get_diffblocks, _perturb\nusing StatsBase\n\nfunction _expect(op::AbstractBlock, reg::ArrayReg; nshots=nothing)\n    if nshots === nothing\n        expect(op, reg)\n    else\n        mean(measure(op, copy(reg); nshots=nshots))\n    end\nend\n\n@inline function my_faithful_grad(op::AbstractBlock, pair::Pair{<:ArrayReg, <:AbstractBlock}; nshots=nothing)\n    map(get_diffblocks(pair.second)) do diffblock\n        r1, r2 = _perturb(()->_expect(op, copy(pair.first) |> pair.second; nshots=nshots) |> real, diffblock, π/2)\n        (r2 - r1)/2\n    end\nend\n\nn = 4\nd = 5\ncircuit = dispatch!(variational_circuit(n, d),:random)\n\ngatecount(circuit)\n\nh = heisenberg(n)\n\nfor i in 1:1000\n      grad = my_faithful_grad(h, zero_state(n) => circuit; nshots=100)\n\n      dispatch!(-, circuit, 1e-2 * grad)\n      println(\"Step $i, energy = $(real.(expect(h, zero_state(n)=>circuit)))\")\nend\n\nusing LinearAlgebra\nw, _ = eigen(Matrix(mat(h)))","category":"page"},{"location":"generated/quick-start/7.variation-quantum-eigen-solver/#","page":"Variational Quantum Eigen Solver","title":"Variational Quantum Eigen Solver","text":"","category":"page"},{"location":"generated/quick-start/7.variation-quantum-eigen-solver/#","page":"Variational Quantum Eigen Solver","title":"Variational Quantum Eigen Solver","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/quick-start/3.grover-search/#","page":"Grover Search","title":"Grover Search","text":"EditURL = \"https://github.com/QuantumBFS/tutorials/blob/master/quick-start/3.grover-search/main.jl\"","category":"page"},{"location":"generated/quick-start/3.grover-search/#","page":"Grover Search","title":"Grover Search","text":"(Image: ) (Image: )","category":"page"},{"location":"generated/quick-start/3.grover-search/#Grover-1","page":"Grover Search","title":"Grover Search","text":"","category":"section"},{"location":"generated/quick-start/3.grover-search/#","page":"Grover Search","title":"Grover Search","text":"using Yao\nusing YaoExtensions: variational_circuit\nusing LinearAlgebra","category":"page"},{"location":"generated/quick-start/3.grover-search/#Grover-Step-1","page":"Grover Search","title":"Grover Step","text":"","category":"section"},{"location":"generated/quick-start/3.grover-search/#","page":"Grover Search","title":"Grover Search","text":"A single grover step is consist of applying oracle circuit and reflection circuit. The reflection_circuit function takes the wave function generator U as the input and returns U|0><0|U'.","category":"page"},{"location":"generated/quick-start/3.grover-search/#","page":"Grover Search","title":"Grover Search","text":"function grover_step!(reg::AbstractRegister, oracle, U::AbstractBlock)\n    apply!(reg |> oracle, reflect_circuit(U))\nend\n\nfunction reflect_circuit(gen::AbstractBlock{N}) where N\n    reflect0 = control(N, -collect(1:N-1), N=>-Z)\n    chain(gen', reflect0, gen)\nend","category":"page"},{"location":"generated/quick-start/3.grover-search/#","page":"Grover Search","title":"Grover Search","text":"Compute the propotion of target states to estimate the number of iterations, which requires computing the output state.","category":"page"},{"location":"generated/quick-start/3.grover-search/#","page":"Grover Search","title":"Grover Search","text":"function solution_state(oracle, gen::AbstractBlock{N}) where N\n    reg= zero_state(N) |> gen\n    reg.state[real.(statevec(ArrayReg(ones(ComplexF64, 1<<N)) |> oracle)) .> 0] .= 0\n    normalize!(reg)\nend\n\nfunction num_grover_step(oracle, gen::AbstractBlock{N}) where N\n    reg = zero_state(N) |> gen\n    ratio = abs2(solution_state(oracle, gen)'*reg)\n    Int(round(pi/4/sqrt(ratio)))-1\nend","category":"page"},{"location":"generated/quick-start/3.grover-search/#Run-1","page":"Grover Search","title":"Run","text":"","category":"section"},{"location":"generated/quick-start/3.grover-search/#","page":"Grover Search","title":"Grover Search","text":"First, we define the problem by an oracle, it finds bit string bit\"000001100100\".","category":"page"},{"location":"generated/quick-start/3.grover-search/#","page":"Grover Search","title":"Grover Search","text":"num_bit = 12\noracle = matblock(Diagonal((v = ones(ComplexF64, 1<<num_bit); v[Int(bit\"000001100100\")+1]*=-1; v)))","category":"page"},{"location":"generated/quick-start/3.grover-search/#","page":"Grover Search","title":"Grover Search","text":"then solve the above problem","category":"page"},{"location":"generated/quick-start/3.grover-search/#","page":"Grover Search","title":"Grover Search","text":"gen = repeat(num_bit, H, 1:num_bit)\nreg = zero_state(num_bit) |> gen\n\ntarget_state = solution_state(oracle, gen)\n\nfor i = 1:num_grover_step(oracle, gen)\n    grover_step!(reg, oracle, gen)\n    overlap = abs(reg'*target_state)\n    println(\"step $(i-1), overlap = $overlap\")\nend","category":"page"},{"location":"generated/quick-start/3.grover-search/#Rejection-Sampling-1","page":"Grover Search","title":"Rejection Sampling","text":"","category":"section"},{"location":"generated/quick-start/3.grover-search/#","page":"Grover Search","title":"Grover Search","text":"In practise, it is often not possible to determine the number of iterations before actual running. we can use rejection sampling technique to avoid estimating the number of grover steps.","category":"page"},{"location":"generated/quick-start/3.grover-search/#","page":"Grover Search","title":"Grover Search","text":"In a single try, we apply the grover algorithm for nstep times.","category":"page"},{"location":"generated/quick-start/3.grover-search/#","page":"Grover Search","title":"Grover Search","text":"function single_try(oracle, gen::AbstractBlock{N}, nstep::Int; nbatch::Int) where N\n    reg = zero_state(N+1; nbatch=nshot)\n    focus!(reg, 1:N) do r\n        r |> gen\n        for i = 1:nstep\n            grover_step!(r, oracle, gen)\n        end\n        return r\n    end\n    reg |> checker\n    res = measure_remove!(reg, (N+1))\n    return res, reg\nend","category":"page"},{"location":"generated/quick-start/3.grover-search/#","page":"Grover Search","title":"Grover Search","text":"After running the grover search, we have a checker program that flips the ancilla qubit if the output is the desired value, we assume the checker program can be implemented in polynomial time. to gaurante the output is correct. We contruct a checker \"program\", if the result is correct, flip the ancilla qubit","category":"page"},{"location":"generated/quick-start/3.grover-search/#","page":"Grover Search","title":"Grover Search","text":"ctrl = -collect(1:num_bit); ctrl[[3,6,7]] *= -1\nchecker = control(num_bit+1,ctrl, num_bit+1=>X)","category":"page"},{"location":"generated/quick-start/3.grover-search/#","page":"Grover Search","title":"Grover Search","text":"The register is batched, with batch dimension nshot. focus! views the first 1-N qubts as system. For a batched register, measure_remove! returns a vector of bitstring as output.","category":"page"},{"location":"generated/quick-start/3.grover-search/#Run-2","page":"Grover Search","title":"Run","text":"","category":"section"},{"location":"generated/quick-start/3.grover-search/#","page":"Grover Search","title":"Grover Search","text":"maxtry = 100\nnshot = 3\n\nfor nstep = 0:maxtry\n    println(\"number of iter = $nstep\")\n    res, reg = single_try(oracle, gen, nstep; nbatch=3)\n\n    # success!\n    if any(==(1), res)\n        overlap_final = viewbatch(reg, findfirst(==(1), res))'*target_state\n        println(\"success, overlap = $(overlap_final)\")\n        break\n    end\nend","category":"page"},{"location":"generated/quick-start/3.grover-search/#","page":"Grover Search","title":"Grover Search","text":"The final state has an overlap of 1 with the target state.","category":"page"},{"location":"generated/quick-start/3.grover-search/#Amplitude-Amplification-1","page":"Grover Search","title":"Amplitude Amplification","text":"","category":"section"},{"location":"generated/quick-start/3.grover-search/#","page":"Grover Search","title":"Grover Search","text":"Given a circuit to generate a state, now we want to project out the subspace with [1,3,5,8,9,11,12] fixed to 1 and [4,6] fixed to 0. We can construct an oracle","category":"page"},{"location":"generated/quick-start/3.grover-search/#","page":"Grover Search","title":"Grover Search","text":"evidense = [1, 3, -4, 5, -6, 8, 9, 11, 12]\nfunction inference_oracle(nbit::Int, locs::Vector{Int})\n    control(nbit, locs[1:end-1], abs(locs[end]) => (locs[end]>0 ? Z : -Z))\nend\noracle = inference_oracle(nqubits(reg), evidense)","category":"page"},{"location":"generated/quick-start/3.grover-search/#","page":"Grover Search","title":"Grover Search","text":"We use a variational circuit generator defined in YaoExtensions","category":"page"},{"location":"generated/quick-start/3.grover-search/#","page":"Grover Search","title":"Grover Search","text":"gen = dispatch!(variational_circuit(num_bit), :random)\nreg = zero_state(num_bit) |> gen","category":"page"},{"location":"generated/quick-start/3.grover-search/#Run-3","page":"Grover Search","title":"Run","text":"","category":"section"},{"location":"generated/quick-start/3.grover-search/#","page":"Grover Search","title":"Grover Search","text":"solution = solution_state(oracle, gen)\nfor i = 1:num_grover_step(oracle, gen)\n    grover_step!(reg, oracle, gen)\n    println(\"step $(i-1), overlap = $(abs(reg'*solution))\")\nend","category":"page"},{"location":"generated/quick-start/3.grover-search/#","page":"Grover Search","title":"Grover Search","text":"","category":"page"},{"location":"generated/quick-start/3.grover-search/#","page":"Grover Search","title":"Grover Search","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/quick-start/2.qft-phase-estimation/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"EditURL = \"https://github.com/QuantumBFS/tutorials/blob/master/quick-start/2.qft-phase-estimation/main.jl\"","category":"page"},{"location":"generated/quick-start/2.qft-phase-estimation/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"(Image: ) (Image: )","category":"page"},{"location":"generated/quick-start/2.qft-phase-estimation/#example-qft-1","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"","category":"section"},{"location":"generated/quick-start/2.qft-phase-estimation/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"Let's use Yao first","category":"page"},{"location":"generated/quick-start/2.qft-phase-estimation/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"using Yao","category":"page"},{"location":"generated/quick-start/2.qft-phase-estimation/#Quantum-Fourier-Transformation-1","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation","text":"","category":"section"},{"location":"generated/quick-start/2.qft-phase-estimation/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"The Quantum Fourier Transformation (QFT) circuit is to repeat two kinds of blocks repeatly:","category":"page"},{"location":"generated/quick-start/2.qft-phase-estimation/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"(Image: qft-circuit)","category":"page"},{"location":"generated/quick-start/2.qft-phase-estimation/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"The basic building block control phase shift gate is defined as","category":"page"},{"location":"generated/quick-start/2.qft-phase-estimation/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"R(k)=beginbmatrix\n1  0\n0  expleft(frac2pi i2^kright)\nendbmatrix","category":"page"},{"location":"generated/quick-start/2.qft-phase-estimation/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"Let's define block A and block B, block A is actually a control block.","category":"page"},{"location":"generated/quick-start/2.qft-phase-estimation/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"A(i, j) = control(i, j=>shift(2π/(1<<(i-j+1))))","category":"page"},{"location":"generated/quick-start/2.qft-phase-estimation/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"Once you construct the blockl you can inspect its matrix using mat function. Let's construct the circuit in dash box A, and see the matrix of R_4 gate.","category":"page"},{"location":"generated/quick-start/2.qft-phase-estimation/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"R4 = A(4, 1)","category":"page"},{"location":"generated/quick-start/2.qft-phase-estimation/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"If you have read about preparing GHZ state, you probably know that in Yao, we could just leave the number of qubits, and it will be evaluated when possible.","category":"page"},{"location":"generated/quick-start/2.qft-phase-estimation/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"R4(5)","category":"page"},{"location":"generated/quick-start/2.qft-phase-estimation/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"its matrix will be","category":"page"},{"location":"generated/quick-start/2.qft-phase-estimation/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"mat(R4(5))","category":"page"},{"location":"generated/quick-start/2.qft-phase-estimation/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"Then we repeat this control block over and over on different qubits, and put a Hadamard gate to ith qubit to construct i-th B block.","category":"page"},{"location":"generated/quick-start/2.qft-phase-estimation/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"B(n, k) = chain(n, j==k ? put(k=>H) : A(j, k) for j in k:n)","category":"page"},{"location":"generated/quick-start/2.qft-phase-estimation/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"We need to input the total number of qubits n here because we have to iterate through from k-th location to the last.","category":"page"},{"location":"generated/quick-start/2.qft-phase-estimation/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"Now, let's construct the circuit by chaining all the B blocks together","category":"page"},{"location":"generated/quick-start/2.qft-phase-estimation/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"qft(n) = chain(B(n, k) for k in 1:n)\nqft(4)","category":"page"},{"location":"generated/quick-start/2.qft-phase-estimation/#Wrap-QFT-to-an-external-block-1","page":"Quantum Fourier Transformation and Phase Estimation","title":"Wrap QFT to an external block","text":"","category":"section"},{"location":"generated/quick-start/2.qft-phase-estimation/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"In most cases, functions are enough to wrap quantum circuits, like A and B we defined above, but sometimes, we need to dispatch specialized methods on certain kinds of quantum circuit, or we want to define an external block to export, thus, it's useful to be able to wrap circuit to custom blocks.","category":"page"},{"location":"generated/quick-start/2.qft-phase-estimation/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"First, we define a new type as subtype of PrimitiveBlock since we are not going to use the subblocks of QFT, if you need to use its subblocks, it'd be better to define it under CompositeBlock.","category":"page"},{"location":"generated/quick-start/2.qft-phase-estimation/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"struct QFT{N} <: PrimitiveBlock{N} end\nQFT(n::Int) = QFT{n}()","category":"page"},{"location":"generated/quick-start/2.qft-phase-estimation/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"Now, let's define its circuit","category":"page"},{"location":"generated/quick-start/2.qft-phase-estimation/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"circuit(::QFT{N}) where N = qft(N)","category":"page"},{"location":"generated/quick-start/2.qft-phase-estimation/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"And forward mat to its circuit's matrix","category":"page"},{"location":"generated/quick-start/2.qft-phase-estimation/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"YaoBlocks.mat(::Type{T}, x::QFT) where T = mat(T, circuit(x))","category":"page"},{"location":"generated/quick-start/2.qft-phase-estimation/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"You may notice, it is a little ugly to print QFT at the moment, this is because we print the type summary by default, you can define your own printing by overloading print_block","category":"page"},{"location":"generated/quick-start/2.qft-phase-estimation/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"YaoBlocks.print_block(io::IO, x::QFT{N}) where N = print(io, \"QFT($N)\")","category":"page"},{"location":"generated/quick-start/2.qft-phase-estimation/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"Since it is possible to use FFT to simulate the results of QFT (like cheating), we could define our custom apply! method:","category":"page"},{"location":"generated/quick-start/2.qft-phase-estimation/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"using FFTW, LinearAlgebra\n\nfunction YaoBlocks.apply!(r::ArrayReg, x::QFT)\n    α = sqrt(length(statevec(r)))\n    invorder!(r)\n    lmul!(α, ifft!(statevec(r)))\n    return r\nend","category":"page"},{"location":"generated/quick-start/2.qft-phase-estimation/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"Now let's check if our apply! method is correct:","category":"page"},{"location":"generated/quick-start/2.qft-phase-estimation/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"r = rand_state(5)\nr1 = r |> copy |> QFT(5)\nr2 = r |> copy |> circuit(QFT(5))\nr1 ≈ r2","category":"page"},{"location":"generated/quick-start/2.qft-phase-estimation/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"We can get iQFT (inverse QFT) directly by calling adjoint","category":"page"},{"location":"generated/quick-start/2.qft-phase-estimation/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"QFT(5)'","category":"page"},{"location":"generated/quick-start/2.qft-phase-estimation/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"QFT and iQFT are different from FFT and IFFT in three ways,","category":"page"},{"location":"generated/quick-start/2.qft-phase-estimation/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"they are different by a factor of sqrt2^n with n the number of qubits.\nthe bit numbering will exchange after applying QFT or iQFT.\ndue to the convention, QFT is more related to IFFT rather than FFT.","category":"page"},{"location":"generated/quick-start/2.qft-phase-estimation/#Phase-Estimation-1","page":"Quantum Fourier Transformation and Phase Estimation","title":"Phase Estimation","text":"","category":"section"},{"location":"generated/quick-start/2.qft-phase-estimation/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"Since we have QFT and iQFT blocks we can then use them to realize phase estimation circuit, what we want to realize is the following circuit:","category":"page"},{"location":"generated/quick-start/2.qft-phase-estimation/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"(Image: phase estimation)","category":"page"},{"location":"generated/quick-start/2.qft-phase-estimation/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"using Yao","category":"page"},{"location":"generated/quick-start/2.qft-phase-estimation/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"First we call Hadamard gates repeatly on first n qubits.","category":"page"},{"location":"generated/quick-start/2.qft-phase-estimation/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"Hadamards(n) = repeat(H, 1:n)","category":"page"},{"location":"generated/quick-start/2.qft-phase-estimation/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"Then in dashed box B, we have controlled unitaries:","category":"page"},{"location":"generated/quick-start/2.qft-phase-estimation/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"ControlU(n, m, U) = chain(n+m, control(k, n+1:n+m=>matblock(U^(2^(k-1)))) for k in 1:n)","category":"page"},{"location":"generated/quick-start/2.qft-phase-estimation/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"each of them is a U of power 2^(k-1).","category":"page"},{"location":"generated/quick-start/2.qft-phase-estimation/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"Since we will only apply the qft and Hadamard on first n qubits, we could use Concentrator, which creates a context of a sub-scope of the qubits.","category":"page"},{"location":"generated/quick-start/2.qft-phase-estimation/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"PE(n, m, U) =\n    chain(n+m, # total number of the qubits\n        concentrate(Hadamards(n), 1:n), # apply H in local scope\n        ControlU(n, m, U),\n        concentrate(QFT(n)', 1:n))","category":"page"},{"location":"generated/quick-start/2.qft-phase-estimation/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"we use the first n qubits as the output space to store phase ϕ, and the other m qubits as the input state which corresponds to an eigenvector of oracle matrix U.","category":"page"},{"location":"generated/quick-start/2.qft-phase-estimation/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"The concentrator here uses focus! and relax! to manage a local scope of quantum circuit, and only active the first n qubits while applying the block inside the concentrator context, and the scope will be relax!ed back, after the context. This is equivalent to manually focus! then relax!","category":"page"},{"location":"generated/quick-start/2.qft-phase-estimation/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"fullly activated","category":"page"},{"location":"generated/quick-start/2.qft-phase-estimation/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"r = rand_state(5)","category":"page"},{"location":"generated/quick-start/2.qft-phase-estimation/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"first 3 qubits activated","category":"page"},{"location":"generated/quick-start/2.qft-phase-estimation/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"focus!(r, 1:3)","category":"page"},{"location":"generated/quick-start/2.qft-phase-estimation/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"relax back to the original","category":"page"},{"location":"generated/quick-start/2.qft-phase-estimation/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"relax!(r, 1:3)","category":"page"},{"location":"generated/quick-start/2.qft-phase-estimation/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"In this way, we will be able to apply small operator directly on the subset of the qubits.","category":"page"},{"location":"generated/quick-start/2.qft-phase-estimation/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"Details about the algorithm can be found here: Quantum Phase Estimation Algorithm","category":"page"},{"location":"generated/quick-start/2.qft-phase-estimation/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"Now let's check the results of our phase estimation.","category":"page"},{"location":"generated/quick-start/2.qft-phase-estimation/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"First we need to set up a unitary with known phase, we set the phase to be 0.75, which is 0.75 * 2^3 == 6 == 0b110 .","category":"page"},{"location":"generated/quick-start/2.qft-phase-estimation/#using-LinearAlgebra-1","page":"Quantum Fourier Transformation and Phase Estimation","title":"using LinearAlgebra","text":"","category":"section"},{"location":"generated/quick-start/2.qft-phase-estimation/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"N, M = 3, 5\nP = eigen(rand_unitary(1<<M)).vectors\nθ = Int(0b110) / 1<<N\nphases = rand(1<<M)\nphases[0b010+1] = θ\nU = P * Diagonal(exp.(2π * im * phases)) * P'","category":"page"},{"location":"generated/quick-start/2.qft-phase-estimation/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"and then generate the state ψ","category":"page"},{"location":"generated/quick-start/2.qft-phase-estimation/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"psi = P[:, 3]","category":"page"},{"location":"generated/quick-start/2.qft-phase-estimation/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"In the phase estimation process, we will feed the state to circuit and measure the first n qubits processed by iQFT.","category":"page"},{"location":"generated/quick-start/2.qft-phase-estimation/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"r = join(ArrayReg(psi), zero_state(N))\nr |> PE(N, M, U)","category":"page"},{"location":"generated/quick-start/2.qft-phase-estimation/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"Since our phase can be represented by 3 qubits precisely, we only need to measure once","category":"page"},{"location":"generated/quick-start/2.qft-phase-estimation/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"results = measure(r, 1:N; nshots=1)","category":"page"},{"location":"generated/quick-start/2.qft-phase-estimation/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"Recall that our QFT's bit numbering is reversed, let's reverse it back","category":"page"},{"location":"generated/quick-start/2.qft-phase-estimation/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"using BitBasis\nestimated_phase = bfloat(results[]; nbits=N)","category":"page"},{"location":"generated/quick-start/2.qft-phase-estimation/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"the phase is exactly 0.75!","category":"page"},{"location":"generated/quick-start/2.qft-phase-estimation/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"","category":"page"},{"location":"generated/quick-start/2.qft-phase-estimation/#","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/quick-start/4.shor-algorithm/#","page":"Shor's Algorithm","title":"Shor's Algorithm","text":"EditURL = \"https://github.com/QuantumBFS/tutorials/blob/master/quick-start/4.shor-algorithm/main.jl\"","category":"page"},{"location":"generated/quick-start/4.shor-algorithm/#","page":"Shor's Algorithm","title":"Shor's Algorithm","text":"(Image: ) (Image: )","category":"page"},{"location":"generated/quick-start/4.shor-algorithm/#Shor-1","page":"Shor's Algorithm","title":"Shor's Algorithm","text":"","category":"section"},{"location":"generated/quick-start/4.shor-algorithm/#References-1","page":"Shor's Algorithm","title":"References","text":"","category":"section"},{"location":"generated/quick-start/4.shor-algorithm/#","page":"Shor's Algorithm","title":"Shor's Algorithm","text":"Neilsen\nAn Insightful Blog","category":"page"},{"location":"generated/quick-start/4.shor-algorithm/#Main-Program-1","page":"Shor's Algorithm","title":"Main Program","text":"","category":"section"},{"location":"generated/quick-start/4.shor-algorithm/#","page":"Shor's Algorithm","title":"Shor's Algorithm","text":"The main program of a Shor's algorithm can be summrized in several lines of code. For the theory part, please refer the reference materials above. It factorize an integer L, and returns one of the factors. Here, the input ver can be either Val(:quantum) or Val(:classical), where the classical version is for comparison.","category":"page"},{"location":"generated/quick-start/4.shor-algorithm/#","page":"Shor's Algorithm","title":"Shor's Algorithm","text":"using Yao, BitBasis\nusing YaoExtensions: KMod, QFTCircuit\nusing QuAlgorithmZoo: NumberTheory\n\nfunction shor(L::Int, ver=Val(:quantum); maxtry=100)\n    L%2 == 0 && return 2\n\n    # find short cut solutions like `a^b`\n    res = NumberTheory.factor_a_power_b(L)\n    res !== nothing && return res[1]\n\n    for i in 1:maxtry\n        # step 1\n        x = NumberTheory.rand_primeto(L)\n\n        # step 2\n        r = get_order(ver, x, L; )\n        if r%2 == 0 && powermod(x, r÷2, L) != L-1\n            # step 3\n            f1, f2 = gcd(powermod(x, r÷2, L)-1, L), gcd(powermod(x, r÷2, L)+1, L)\n            if f1!=1\n                return f1\n            elseif f2!=1\n                return f2\n            else\n                error(\"Algorithm Fail!\")\n            end\n        end\n    end\nend","category":"page"},{"location":"generated/quick-start/4.shor-algorithm/#","page":"Shor's Algorithm","title":"Shor's Algorithm","text":"Except some shortcuts, in each try, the main program can be summarized in several steps","category":"page"},{"location":"generated/quick-start/4.shor-algorithm/#","page":"Shor's Algorithm","title":"Shor's Algorithm","text":"randomly pick a number that prime to the input numebr L, i.e. gcd(x, L) = 1.","category":"page"},{"location":"generated/quick-start/4.shor-algorithm/#","page":"Shor's Algorithm","title":"Shor's Algorithm","text":"The complexity of this algorithm is polynoial.","category":"page"},{"location":"generated/quick-start/4.shor-algorithm/#","page":"Shor's Algorithm","title":"Shor's Algorithm","text":"get the order x, i.e. finding a number r that satisfies mod(x^r, L) = 1.","category":"page"},{"location":"generated/quick-start/4.shor-algorithm/#","page":"Shor's Algorithm","title":"Shor's Algorithm","text":"If r is even and x^(r÷2) is non-trivil, go on, otherwise start another try. Here, trivil means equal to L-1 (mod L).","category":"page"},{"location":"generated/quick-start/4.shor-algorithm/#","page":"Shor's Algorithm","title":"Shor's Algorithm","text":"According to Theorem 5.2 in Neilsen book,","category":"page"},{"location":"generated/quick-start/4.shor-algorithm/#","page":"Shor's Algorithm","title":"Shor's Algorithm","text":"one of gcd(x^(r÷2)-1, L) and gcd(x^(r÷2)+1, L) must be a non-trivil (!=1) factor of L. Notice powermod(x, r÷2, L) must be -1 rather than 1, otherwise the order should be r/2 according to definition.","category":"page"},{"location":"generated/quick-start/4.shor-algorithm/#","page":"Shor's Algorithm","title":"Shor's Algorithm","text":"The only difference between classical and quantum version is the order finding algorithm.","category":"page"},{"location":"generated/quick-start/4.shor-algorithm/#Order-Finding-1","page":"Shor's Algorithm","title":"Order Finding","text":"","category":"section"},{"location":"generated/quick-start/4.shor-algorithm/#","page":"Shor's Algorithm","title":"Shor's Algorithm","text":"We provided a classical order finding algorithm in NumberTheory, here we focus on the quantum version. The algorithm is consisted","category":"page"},{"location":"generated/quick-start/4.shor-algorithm/#","page":"Shor's Algorithm","title":"Shor's Algorithm","text":"run the circuit to get a bitstring,\ninterpret this bitstring in output register as a rational number s/r.","category":"page"},{"location":"generated/quick-start/4.shor-algorithm/#","page":"Shor's Algorithm","title":"Shor's Algorithm","text":"To achieve this, we first interpret it as a floating point number, then the continued fraction algorithm can find the best match for us.","category":"page"},{"location":"generated/quick-start/4.shor-algorithm/#","page":"Shor's Algorithm","title":"Shor's Algorithm","text":"When using the quantum version, we have the flexibility to set key word arguments nshot, nbit (size of input data register) and ncbit (size of control register, or output register). nbit can be simply chosen as the minimum register size to store input, while ncbit can be estimated with the following function","category":"page"},{"location":"generated/quick-start/4.shor-algorithm/#","page":"Shor's Algorithm","title":"Shor's Algorithm","text":"\"\"\"estimate the required size of the output register.\"\"\"\nestimate_ncbit(nbit::Int, ϵ::Real) = 2*nbit + 1 + ceil(Int,log2(2+1/2ϵ))\n\nget_order(::Val{:classical}, x::Int, L::Int; kwargs...) = NumberTheory.find_order(x, L)\nfunction get_order(::Val{:quantum}, x::Int, L::Int; nshots::Int=10,\n            nbit::Int=bit_length(L-1), ncbit::Int=estimate_ncbit(nbit, 0.25))\n    c = order_finding_circuit(x, L; nbit=nbit, ncbit=ncbit)\n    reg = join(product_state(nbit, 1), zero_state(ncbit))\n\n    res = measure(copy(reg) |> c; nshots=nshots)\n    for r in res\n        # split bit string b into lower bits `k` and higher bits `r`.\n        mask = bmask(1:ncbit)\n        k,i = r&mask, r>>ncbit\n        # get s/r\n        ϕ = bfloat(k)  #\n        ϕ == 0 && continue\n\n        # order_from_float: given a floating point number,\n        # return the closest rational number with bounded number of continued fraction steps.\n        order = NumberTheory.order_from_float(ϕ, x, L)\n        if order === nothing\n            continue\n        else\n            return order\n        end\n    end\n    return nothing\nend","category":"page"},{"location":"generated/quick-start/4.shor-algorithm/#The-circuit-used-for-finding-order-1","page":"Shor's Algorithm","title":"The circuit used for finding order","text":"","category":"section"},{"location":"generated/quick-start/4.shor-algorithm/#","page":"Shor's Algorithm","title":"Shor's Algorithm","text":"\"\"\"\n    order_finding_circuit(x::Int, L::Int; nbit::Int=bit_length(L-1), ncbit::Int=estimate_ncbit(nbit, 0.25)) -> AbstractBlock\n\nReturns the circuit for finding the order of `x` to `L`,\nfeeding input `|1>⊗|0>` will get the resulting quantum register with the desired \"phase\" information.\n\"\"\"\nfunction order_finding_circuit(x::Int, L::Int; nbit::Int, ncbit::Int)\n    N = nbit+ncbit\n    chain(N, repeat(N, H, 1:ncbit), KMod{N, ncbit}(x, L),\n        concentrate(N, QFTCircuit(ncbit)', 1:ncbit))\nend","category":"page"},{"location":"generated/quick-start/4.shor-algorithm/#","page":"Shor's Algorithm","title":"Shor's Algorithm","text":"The circuit for order finding is consisted of three parts","category":"page"},{"location":"generated/quick-start/4.shor-algorithm/#","page":"Shor's Algorithm","title":"Shor's Algorithm","text":"Hadamard gates,\nKMod that computes a classical function mod(a^k*x, L).","category":"page"},{"location":"generated/quick-start/4.shor-algorithm/#","page":"Shor's Algorithm","title":"Shor's Algorithm","text":"k is the integer stored in first K (or ncbit) qubits and the rest N-K qubits stores a. Notice it is not a basic gate, it should have been compiled to multiple gates, which is not implemented in Yao for the moment. To learn more about implementing arithmatics on a quantum circuit, please read this paper.","category":"page"},{"location":"generated/quick-start/4.shor-algorithm/#","page":"Shor's Algorithm","title":"Shor's Algorithm","text":"Inverse quantum fourier transformation.","category":"page"},{"location":"generated/quick-start/4.shor-algorithm/#Run-1","page":"Shor's Algorithm","title":"Run","text":"","category":"section"},{"location":"generated/quick-start/4.shor-algorithm/#","page":"Shor's Algorithm","title":"Shor's Algorithm","text":"Factorizing 15, you should see 3 or 5, please report a bug if it is not...","category":"page"},{"location":"generated/quick-start/4.shor-algorithm/#","page":"Shor's Algorithm","title":"Shor's Algorithm","text":"shor(15, Val(:quantum))","category":"page"},{"location":"generated/quick-start/4.shor-algorithm/#","page":"Shor's Algorithm","title":"Shor's Algorithm","text":"","category":"page"},{"location":"generated/quick-start/4.shor-algorithm/#","page":"Shor's Algorithm","title":"Shor's Algorithm","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/developer-guide/1.extending-register/#","page":"Extending Register: an echo register","title":"Extending Register: an echo register","text":"EditURL = \"https://github.com/QuantumBFS/tutorials/blob/master/developer-guide/1.extending-register/main.jl\"","category":"page"},{"location":"generated/developer-guide/1.extending-register/#","page":"Extending Register: an echo register","title":"Extending Register: an echo register","text":"(Image: ) (Image: )","category":"page"},{"location":"generated/developer-guide/1.extending-register/#Extending-Register:-an-echo-register-1","page":"Extending Register: an echo register","title":"Extending Register: an echo register","text":"","category":"section"},{"location":"generated/developer-guide/1.extending-register/#","page":"Extending Register: an echo register","title":"Extending Register: an echo register","text":"We show how to extend a register that prints the instructions to standard output instead of actually exexcuting the instructions.","category":"page"},{"location":"generated/developer-guide/1.extending-register/#","page":"Extending Register: an echo register","title":"Extending Register: an echo register","text":"using Yao","category":"page"},{"location":"generated/developer-guide/1.extending-register/#","page":"Extending Register: an echo register","title":"Extending Register: an echo register","text":"First you will need to define your own subtype that contains your desired data structure","category":"page"},{"location":"generated/developer-guide/1.extending-register/#","page":"Extending Register: an echo register","title":"Extending Register: an echo register","text":"mutable struct EchoReg{B} <: AbstractRegister{B}\n    nactive::Int\n    nqubits::Int\nend","category":"page"},{"location":"generated/developer-guide/1.extending-register/#","page":"Extending Register: an echo register","title":"Extending Register: an echo register","text":"Then we need to define the most basic API: how many qubits are there","category":"page"},{"location":"generated/developer-guide/1.extending-register/#","page":"Extending Register: an echo register","title":"Extending Register: an echo register","text":"Yao.nactive(reg::EchoReg) = reg.nactive\nYao.nqubits(reg::EchoReg) = reg.nqubits","category":"page"},{"location":"generated/developer-guide/1.extending-register/#","page":"Extending Register: an echo register","title":"Extending Register: an echo register","text":"And define some instructions, as an echo register, we will just keep printing what we are asked to exexcute","category":"page"},{"location":"generated/developer-guide/1.extending-register/#","page":"Extending Register: an echo register","title":"Extending Register: an echo register","text":"function Yao.instruct!(::EchoReg{B}, args...) where {B, G}\n    str = join(string.(args), \", \")\n    println(\"calls: instruct!(reg, $str)\")\nend\n\nfunction Yao.focus!(reg::EchoReg{B}, locs) where {B}\n    println(\"focus -> $locs\")\n    reg.nactive = length(locs)\n    return true\nend\n\nfunction Yao.relax!(reg::EchoReg{B}, locs; to_nactive=nqubits(reg)) where {B}\n    reg.nactive = to_nactive\n    println(\"relax -> $locs\\\\$to_nactive\")\n    return true\nend\n\nfunction Yao.measure!(rng, ::ComputationalBasis, reg::EchoReg{B}, locs) where {B}\n    println(\"measure -> $locs\")\n    return true\nend","category":"page"},{"location":"generated/developer-guide/1.extending-register/#","page":"Extending Register: an echo register","title":"Extending Register: an echo register","text":"Now we can check what will happen!","category":"page"},{"location":"generated/developer-guide/1.extending-register/#","page":"Extending Register: an echo register","title":"Extending Register: an echo register","text":"r = EchoReg{10}(3, 2)\nr |> put(3, 2=>X) |> control(3, 3, 2=>X) |> concentrate(3, put(1, 1=>X), 2:2) |> measure!","category":"page"},{"location":"generated/developer-guide/1.extending-register/#","page":"Extending Register: an echo register","title":"Extending Register: an echo register","text":"But when we still require some more information from you","category":"page"},{"location":"generated/developer-guide/1.extending-register/#","page":"Extending Register: an echo register","title":"Extending Register: an echo register","text":"r |> cache(X)","category":"page"},{"location":"generated/developer-guide/1.extending-register/#","page":"Extending Register: an echo register","title":"Extending Register: an echo register","text":"An NotImplementedError will be thrown, no worries!","category":"page"},{"location":"generated/developer-guide/1.extending-register/#","page":"Extending Register: an echo register","title":"Extending Register: an echo register","text":"","category":"page"},{"location":"generated/developer-guide/1.extending-register/#","page":"Extending Register: an echo register","title":"Extending Register: an echo register","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/developer-guide/3.extern-libraries/#","page":"Using External Libraries","title":"Using External Libraries","text":"EditURL = \"https://github.com/QuantumBFS/tutorials/blob/master/developer-guide/3.extern-libraries/main.jl\"","category":"page"},{"location":"generated/developer-guide/3.extern-libraries/#","page":"Using External Libraries","title":"Using External Libraries","text":"(Image: ) (Image: )","category":"page"},{"location":"generated/developer-guide/3.extern-libraries/#Using-External-Libraries-1","page":"Using External Libraries","title":"Using External Libraries","text":"","category":"section"},{"location":"generated/developer-guide/3.extern-libraries/#","page":"Using External Libraries","title":"Using External Libraries","text":"It is straightforward to make use of external libraries written in other language. For example, the following codes import modules from the OpenFermion and construct a qubit Hamiltonian for molecules as quantum blocks in Yao.","category":"page"},{"location":"generated/developer-guide/3.extern-libraries/#","page":"Using External Libraries","title":"Using External Libraries","text":"using Yao\nusing LinearAlgebra\nusing PyCall","category":"page"},{"location":"generated/developer-guide/3.extern-libraries/#","page":"Using External Libraries","title":"Using External Libraries","text":"Install OpenFermion and PySCF if you don't have them","category":"page"},{"location":"generated/developer-guide/3.extern-libraries/#","page":"Using External Libraries","title":"Using External Libraries","text":"pip = pyimport(\"pip._internal.main\")\npip.main([\"install\", \"pyscf\", \"openfermion\", \"openfermionpyscf\"])","category":"page"},{"location":"generated/developer-guide/3.extern-libraries/#","page":"Using External Libraries","title":"Using External Libraries","text":"First we import hamiltonians from OpenFermion and PySCF","category":"page"},{"location":"generated/developer-guide/3.extern-libraries/#","page":"Using External Libraries","title":"Using External Libraries","text":"of_hamil = pyimport(\"openfermion.hamiltonians\")\nof_trsfm = pyimport(\"openfermion.transforms\")\nof_pyscf = pyimport(\"openfermionpyscf\")","category":"page"},{"location":"generated/developer-guide/3.extern-libraries/#","page":"Using External Libraries","title":"Using External Libraries","text":"following the OpenFermion and PySCF tutorial, we define molecules from data.","category":"page"},{"location":"generated/developer-guide/3.extern-libraries/#","page":"Using External Libraries","title":"Using External Libraries","text":"diatomic_bond_length = 1.0\ngeometry = [(\"H\", (0., 0., 0.)), (\"H\", (0., 0., diatomic_bond_length))]\nbasis = \"sto-3g\"\nmultiplicity = 1\ncharge = 0\ndescription = string(diatomic_bond_length)\n\nmolecule = of_hamil.MolecularData(geometry, basis, multiplicity, charge, description)\nmolecule = of_pyscf.run_pyscf(molecule,run_scf=1,run_fci=1)","category":"page"},{"location":"generated/developer-guide/3.extern-libraries/#","page":"Using External Libraries","title":"Using External Libraries","text":"Then obtain its Hamiltonian","category":"page"},{"location":"generated/developer-guide/3.extern-libraries/#","page":"Using External Libraries","title":"Using External Libraries","text":"m_h = molecule.get_molecular_hamiltonian()\nnbits = m_h.n_qubits\n\njw_h = of_trsfm.jordan_wigner(of_trsfm.get_fermion_operator(m_h))","category":"page"},{"location":"generated/developer-guide/3.extern-libraries/#","page":"Using External Libraries","title":"Using External Libraries","text":"now, let's construct the corresponding Hamiltonian in Yao","category":"page"},{"location":"generated/developer-guide/3.extern-libraries/#","page":"Using External Libraries","title":"Using External Libraries","text":"function yao_hamiltonian(nbits, jw_h)\n    gates = Dict(\"X\"=>X, \"Y\"=>Y, \"Z\"=>Z)\n    h = Add{nbits}()\n    for (k, v) in jw_h.terms\n        op = v*put(nbits, 1=>I2)\n        for t in k\n            site, opname = t\n            op = op*put(nbits, site+1=>gates[opname])\n        end\n        push!(h, op)\n    end\n    h\nend","category":"page"},{"location":"generated/developer-guide/3.extern-libraries/#","page":"Using External Libraries","title":"Using External Libraries","text":"Yah!","category":"page"},{"location":"generated/developer-guide/3.extern-libraries/#","page":"Using External Libraries","title":"Using External Libraries","text":"yao_h = yao_hamiltonian(nbits, jw_h)","category":"page"},{"location":"generated/developer-guide/3.extern-libraries/#","page":"Using External Libraries","title":"Using External Libraries","text":"now let's try to calculate its eigen values","category":"page"},{"location":"generated/developer-guide/3.extern-libraries/#","page":"Using External Libraries","title":"Using External Libraries","text":"w, v = eigen(Matrix(yao_h))","category":"page"},{"location":"generated/developer-guide/3.extern-libraries/#","page":"Using External Libraries","title":"Using External Libraries","text":"","category":"page"},{"location":"generated/developer-guide/3.extern-libraries/#","page":"Using External Libraries","title":"Using External Libraries","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#Yao-Tutorial-1","page":"Home","title":"Yao Tutorial","text":"","category":"section"}]
}
